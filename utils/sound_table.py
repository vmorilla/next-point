#!/usr/bin/env python3

import os
import sys


# Iterates through the files system given the path and the sound list
def get_file_length(sound_file: str) -> int:
    """
    Get the length of a sound file
    """
    if not os.path.isfile(sound_file):
        raise FileNotFoundError(f"Sound file {sound_file} not found.")
    else:
        return os.path.getsize(sound_file)


# # Produces a list of the length of the raw files corresponding to the sounds
# def get_sound_lengths(path: str, sounds: list[str]) -> list[int]:
#     """
#     Get the lengths of the sound files in seconds.
#     """

#     return [get_file_length(sound) for sound in sounds]


def sound_label(sound: str) -> str:
    return sound.replace("/", "_")


def split_file(input_file, output_dir, page, size_list):
    with open(input_file, "rb") as f:
        for i, s in enumerate(size_list):
            chunk = f.read(s)
            if not chunk:
                raise EOFError(f"Cannot split file {input_file}")
            with open(f"{output_dir}_page_{page + i}.raw", "wb") as out:
                out.write(chunk)


# An array with an entry per file. Each entry is an object like this:
# {
#     label,
#     page,
#     chunks[]
# }
# each chunk
# page, file_name, size

PAGE_SIZE = 8192
TABLE_ITEM_SIZE = 5


def chunk_name(output_dir, sound, page):
    return f"{output_dir}/{sound}_page_{page}.bin"


def preprocess_files(path, page, sounds):
    sound_data = []
    memory_offset = TABLE_ITEM_SIZE * len(sounds)

    for sound in sounds:
        chunks = []
        sound_file = f"{path}/{sound}.raw"
        length = get_file_length(sound_file)
        if length >= 0xFFFF:
            raise ValueError(f"Sound file {sound_file} is too long: {length} bytes")
        sound_data.append(
            {
                "label": sound_label(sound),
                "file": sound_file,
                "page": page,
                "length": length,
                "chunks": chunks,
            }
        )

        while length > 0:
            next_chunk_size = min(length, PAGE_SIZE - memory_offset)
            chunks.append(
                {
                    "page": page,
                    "file": chunk_name(path, sound, page),
                    "size": next_chunk_size,
                }
            )
            length -= next_chunk_size
            memory_offset = memory_offset + next_chunk_size
            if memory_offset == PAGE_SIZE:
                memory_offset = 0
                page += 1

    return sound_data


def write_asm_file(sound_data, base_page):
    print("; File generated by sound_table.py")
    print("; Do not edit this file.")
    print()
    start_section(base_page)
    print("PUBLIC _sounds_table")
    print()
    print("_sounds_table:")
    for item in sound_data:
        print(f'\tdefb {item["page"]}')
        print(f'\tdefw {item["label"]}, {item["length"]}')

    print()

    page = base_page
    for item in sound_data:
        item_page = item["page"]
        if item_page > page:
            start_section(item_page)
            page = item_page

        print(f'{item["label"]}:')
        for chunk in item["chunks"]:
            chunk_page = chunk["page"]
            if chunk_page > page:
                start_section(chunk_page)
                page = chunk_page
            print(f'\tbinary "{chunk["file"]}"\n')


def split_sound_files(sound_data):
    for item in sound_data:
        file = item["file"]
        with open(file, "rb") as f:
            for c in item["chunks"]:
                chunk = f.read(c["size"])
                if not chunk:
                    raise EOFError(f"Cannot split file {file}")
                with open(f"{c['file']}", "wb") as out:
                    out.write(chunk)


def start_section(page):
    """
    Start a new section in the asm file.
    """
    print(f"SECTION PAGE_{page}")
    print("\tORG $c000")
    print()


def main():
    """
    Main function to test the sound lengths.
    """

    # Path to the sounds
    path = sys.argv[1]
    # path = "build"

    # List of sounds
    sounds = [
        "sounds/out",
        "sounds/fault",
        "sounds/double_fault",
        "sounds/first_service",
        "sounds/second_service",
        "sounds/let",
        "sounds/touch",
        "sounds/game_point",
        "sounds/set_point",
        "sounds/match_point",
        "sounds/game_receiver",
        "sounds/game_server",
        "sounds/set_receiver",
        "sounds/set_server",
        "sounds/match_receiver",
        "sounds/match_server",
        # Sounds
        "sounds/ball_bounce",
        "sounds/ball_hit",
        "sounds/ball_hit_2",
        "sounds/net",
        # The followin set of sounds should be kept in order
        "sounds/score_0_15",
        "sounds/score_0_30",
        "sounds/score_0_40",
        "sounds/score_15_0",
        "sounds/score_15_15",
        "sounds/score_15_30",
        "sounds/score_15_40",
        "sounds/score_30_0",
        "sounds/score_30_15",
        "sounds/score_30_30",
        "sounds/score_30_40",
        "sounds/score_40_0",
        "sounds/score_40_15",
        "sounds/score_40_30",
        "sounds/deuce",
        "sounds/ad_receiver",
        "sounds/ad_server",
        # More sounds
        "sounds/umpf_diego_1",
        "sounds/umpf_diego_2",
        "sounds/umpf_victor_1",
        "sounds/umpf_victor_2",
        "sounds/crowd_clapping",
        "sounds/touch_hit_male",
        # The crowd is too long... it produces a segment overflow
        # "voices/crowd_clapping",
    ]

    base_page = 100
    data = preprocess_files(path, base_page, sounds)

    # Write the asm file loading all sound binaries
    write_asm_file(data, base_page)

    # Write the sound chunks per page
    split_sound_files(data)


if __name__ == "__main__":
    main()


# SECTION PAGE_100

# PUBLIC _sounds_table

# _sounds_table:
#     defb PAGE
#     defw _sound_ball_bounce, LENGTH
#     defb 100
#     defw _sound_ball_hit, _sound_ball_hit_end - _sound_ball_hit
#     defb 100
#     defw _voice_out, _voice_out_end - _voice_out

# _sound_ball_bounce:
#    binary "../assets/sounds/ball_bounce.raw"
# _sound_ball_bounce_end:

# _sound_ball_hit:
#    binary "../assets/sounds/ball_hit.raw"
# _sound_ball_hit_end:

# _voice_out:
#    binary "../build/voices/out.raw"
# _voice_out_end:
