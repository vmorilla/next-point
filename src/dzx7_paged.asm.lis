/tmp/tmpp7nQbojp.asm:
     1                          MODULE dzx7_paged_asm
     2                          LINE 0, "dzx7_paged.asm"
dzx7_paged.asm:
                                
     1                          
     2                          ; ===============================================================
     3                          ; Based on the code by Einar Saukas, Antonio Villena & Metalbrain
     4                          ; ===============================================================
     5                          ;
     6                          ; void* dzx7_paged(void *src, void *dst)
     7                          ;
     8                          ; Decompress the compressed block at address src to address dst.
     9                          ; Address src is assumed to be in the slot 6 page. If the pointer
    10                          ; exceeds the page, it will switch to the next bank using the
    11                          ; paging calls.
    12                          ; The function does not restore the slot 6 page and returns the
    13                          ; next source address. This way, it can be used to chain multiple
    14                          ; calls to decompress blocks, for instance, to fill in the layer2
    15                          ; ===============================================================
    16                          
    17                          include "macros.inc"
macros.inc:
     1                          #define READ_NEXTREG(REG) \
     2                              push bc : \
     3                              ld a, REG :\
     4                              ld bc, $243b :\
     5                              out (c), a :\
     6                              inc b :\
     7                              in a, (c) :\
     8                              pop bc
     9                          
    10                          
    11                          defc CTC0 = 0x183B ; CTC channel 0 port
    12                          defc CTC1 = 0x193B ; CTC channel 1 port
    13                          defc CTC2 = 0x1A3B ; CTC channel 2 port
    14                          defc CTC3 = 0x1B3B ; CTC channel 3 port
    15                          
    16                          defc IO_DAC_L0 = 0x0f
    17                          defc IO_DAC_L1 = 0x1f
    18                          defc IO_DAC_R0 = 0x4f
    19                          defc IO_DAC_R1 = 0x5f
    20                          defc IO_DAC_M0 = 0xdf
    21                          
    22                          defc INTERRUPT_STATUS_CTC = $C9
    23                          
    24                          defc REG_MMU6 = 0x56
    25                          
    26                          defc AY_REG = 0xFFFD ;   // AY register select port
    27                          defc AY_DATA = 0xBFFD ; // AY register data port
    28                          
    29                          defc AY_TONE_A_LO = 0x00 ; // R0 fine tune A
    30                          defc AY_TONE_A_HI = 0x01 ; // R1 coarse tune A
    31                          defc AY_TONE_B_LO = 0x02 ; // R2 fine tune B
    32                          defc AY_TONE_B_HI = 0x03 ; // R3 coarse tune B
    33                          defc AY_TONE_C_LO = 0x04 ; // R4 fine tune C
    34                          defc AY_TONE_C_HI = 0x05 ; // R5 coarse tune C
    35                          defc AY_NOISE = 0x06 ; // R6 noise period
    36                          defc AY_MIXER = 0x07 ; // R7 mixer register
    37                          defc AY_VOLUME_A = 0x08 ; // R8 volume A
    38                          defc AY_VOLUME_B = 0x09 ; // R9 volume B
    39                          defc AY_VOLUME_C = 0x0A ; // R10 volume C
    40                          defc AY_ENV_LO = 0x0B ; // R11 envelope low
    41                          defc AY_ENV_HI = 0x0C ; // R12 envelope high
    42                          defc AY_ENV_SHAPE = 0x0D ; // R13 envelope shape
    43                          
dzx7_paged.asm:
    18                          
    19                          SECTION code_user
    20                          
    21                          PUBLIC _dzx7_paged
    22                          
    23                          _dzx7_paged:
    24                              ; This function decompresses a block of data using the DZX7
    25                              ; algorithm. The compressed data is read from the source address
    26                              ; and the decompressed data is written to the destination address.
    27                              ;
    28                              ; entry : parameters stored in stack from right to left
    29                              ; exit  : hl = following uncompressed block
    30                              ;
    31                              ; uses  : af, bc, de, hl
    32                          
    33                             ; enter : hl = void *src
    34                             ;         de = void *dst
    35                             ;
    36                             ; exit  : hl = address following uncompressed block + 2 bytes
    37                             ;
    38                             ; uses  : af, bc, de, hl
    39  0000  dde5                  push ix
    40  0002  dd210400              ld ix, 4
    41  0006  dd39                  add ix, sp
    42  0008  dd6e00dd6601          ld hl, (ix)                ; hl = src
    43  000e  dd5e02dd5603          ld de, (ix + 2)            ; de = dst
    44                          
    45  0014  3e80                  ld a, $80
    46                          
    47                          dzx7p_copy_byte_loop:
    48                          
    49  0016  eda0                  ldi                              ; copy literal byte
    50  0018  cd6700                call check_page
    51                          
    52                          dzx7p_main_loop:
    53                          
    54  001b  cd5a00                call    dzx7p_next_bit
    55  001e  30f6                  jr      nc, dzx7p_copy_byte_loop ; next bit indicates either literal or sequence
    56                          
    57                          ; determine number of bits used for length (Elias gamma coding)
    58                          
    59  0020  d5                    push    de            ; stores destination in (sp)
    60  0021  010000                ld      bc, 0
    61  0024  50                    ld      d, b
    62                          
    63                          dzx7p_len_size_loop:
    64                          
    65  0025  14                    inc     d
    66  0026  cd5a00                call    dzx7p_next_bit
    67  0029  30fa                  jr      nc, dzx7p_len_size_loop
    68                          
    69                          ; determine length
    70                          
    71                          dzx7p_len_value_loop:
    72                          
    73  002b  d45a00                call    nc, dzx7p_next_bit
    74  002e  cb11                  rl      c
    75  0030  cb10                  rl      b
    76  0032  382f                  jr      c, dzx7p_exit
    77  0034  15                    dec     d
    78  0035  20f4                  jr      nz, dzx7p_len_value_loop
    79  0037  03                    inc     bc                          ; adjust length
    80                          
    81                          ; determine offset
    82                          
    83  0038  5e                    ld e, (hl)                 ; load offset flag (1 bit) + offset value (7 bits)
    84  0039  23                    inc hl
    85  003a  cd6700                call check_page
    86  003d  cb23                  sla e
    87  003f  1c                    inc e
    88  0040  300c                  jr      nc, dzx7p_offset_end    ; if offset flag is set, load 4 extra bits
    89  0042  1610                  ld      d, $10                  ; bit marker to load 4 bits
    90                          
    91                          dzx7p_rld_next_bit:
    92  0044  cd5a00                call    dzx7p_next_bit
    93  0047  cb12                  rl      d                       ; insert next bit into D
    94  0049  30f9                  jr      nc, dzx7p_rld_next_bit  ; repeat 4 times, until bit marker is out
    95  004b  14                    inc     d                       ; add 128 to DE
    96  004c  cb3a                  srl	d			; retrieve fourth bit from D
    97                          
    98                          dzx7p_offset_end:
    99  004e  cb1b                  rr      e                       ; insert fourth bit into E
   100                          
   101                          ; copy previous sequence
   102                          
   103  0050  e3                    ex      (sp), hl                ; store source, restore destination
   104  0051  e5                    push    hl                      ; store destination
   105  0052  ed52                  sbc     hl, de                  ; HL = destination - offset - 1
   106  0054  d1                    pop     de                      ; DE = destination
   107  0055  edb0                  ldir
   108  0057  e1                    pop hl                      ; restore source address (compressed data)
   109  0058  30c1                  jr nc, dzx7p_main_loop
   110                          
   111                          dzx7p_next_bit:
   112  005a  87                    add a, a                    ; check next bit
   113  005b  c0                    ret nz                      ; no more bits left?
   114  005c  7e                    ld a, (hl)                 ; load another group of 8 bits
   115  005d  23                    inc hl
   116  005e  cd6700                call check_page
   117  0061  17                    rla
   118  0062  c9                    ret
   119                          
   120                          dzx7p_exit:
   121  0063  d1                    pop de          ; restores the stack and returns
   122  0064  dde1                  pop ix          ; restores ix
   123  0066  c9                    ret
   124                          
   125                              ; Checks if hl exceeds the slot 6 page. If so, it
   126                              ; moves to the next page.
   127                          check_page:
   128  0067  cb6c                  bit 5, h
   129  0069  c8                    ret z
   130  006a  f5                    push af
   131  006b  26c0                  ld h, 0xc0          ; start of slot 6
   132  006d  c53e56013b24ed79      READ_NEXTREG(REG_MMU6)
              04ed78c1          
   133  0079  3c                    inc a
   134  007a  ed9256                nextreg REG_MMU6, a
   135  007d  f1                    pop af
   136  007e  c9                    ret
   137                          
